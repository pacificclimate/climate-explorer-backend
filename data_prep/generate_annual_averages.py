import os, os.path
import re
import logging
import sys

from argparse import ArgumentParser
from datetime import datetime
from tempfile import NamedTemporaryFile

from cdo import Cdo
from netCDF4 import Dataset, num2date, date2num
from dateutil.relativedelta import relativedelta

from Cmip5File import Cmip5File

log = logging.getLogger(__name__)
logging.basicConfig(stream=sys.stdout, level=4)

def iter_matching(dirpath, regexp):
    # http://stackoverflow.com/questions/4639506/os-walk-with-regex
    """Generator yielding all files under `dirpath` whose absolute path
       matches the regular expression `regexp`.
       Usage:

           >>> for filename in iter_matching('/', r'/home.*\.bak'):
           ....    # do something
    """
    for dir_, dirnames, filenames in os.walk(dirpath):
        for filename in filenames:
            abspath = os.path.join(dir_, filename)
            if regexp.match(abspath):
                yield abspath

def create_annual_avg_file(in_fp, out_fp, variable):
    '''
    Generates file with annual averages for the given variable across all time within an input file

    Parameters:
        in_fp: input file path
        out_fp: output file path
        variable (str): name of the variable which is being processed

    '''
    supported_vars = {
        'cddETCCDI', 'csdiETCCDI', 'cwdETCCDI', 'dtrETCCDI', 'fdETCCDI',
        'gslETCCDI', 'idETCCDI', 'prcptotETCCDI', 'r10mmETCCDI', 'r1mmETCCDI',
        'r20mmETCCDI', 'r95pETCCDI', 'r99pETCCDI', 'rx1dayETCCDI',
        'rx5dayETCCDI', 'sdiiETCCDI', 'suETCCDI', 'thresholds', 'tn10pETCCDI',
        'tn90pETCCDI', 'tnnETCCDI', 'tnxETCCDI', 'trETCCDI', 'tx10pETCCDI',
        'tx90pETCCDI', 'txnETCCDI', 'txxETCCDI', 'wsdiETCCDI', 'tasmin',
        'tasmax', 'pr'
    }

    if variable not in supported_vars:
        raise Exception("Unsupported variable: can't yet process {}".format(variable))

    if not os.path.exists(os.path.dirname(out_fp)):
        os.makedirs(os.path.dirname(out_fp))

    cdo = Cdo()
    cdo.yearmean(input=in_fp, output=out_fp)

def update_annual_avg_time_metadata(nc):
    '''
    Converts time values of a newly produced annual average NetCDF file (nc) to annual midpoints
    and adds a time bounds variable

    time values are the calculated midpoint between <year x>-01-01 and <year x+1>-01-01
    time bounds are <year x>-01-01 00:00:00 and <year x+1>-01-01 00:00:00
    '''
    time_var = nc.variables['time']
    units = nc.variables['time'].units
    calendar = nc.variables['time'].calendar
    start_year = num2date(time_var[0], units, calendar).year
    end_year = start_year + time_var.shape[0]

    new_times = []
    bounds_var = nc.variables['time_bnds']
    new_bounds = []

    for year in range(start_year, end_year):
        days_to_mid = ((datetime(year, 1, 1) + relativedelta(years=1)) - datetime(year, 1, 1)).days/2
        mid = datetime(year, 1, 1) + relativedelta(days=days_to_mid)
        new_times.append(mid)
        lower_bound = datetime(year, 1, 1)
        upper_bound = datetime(year, 1, 1) + relativedelta(years=1)
        new_bounds.append([lower_bound, upper_bound])

    time_var[:] = date2num(new_times, units, calendar)
    bounds_var[:] = date2num(new_bounds, units, calendar)

def update_annual_avg_file_metadata(out_fp, variable):
    '''
    Opens generated yearmean NetCDF file and modifies global and variable metadata

    Parameters:
        out_fp: output file path
        variable (str): name of the CMIP5 variable present in the output file
    '''

    nc = Dataset(out_fp, 'r+')
    # modify global metadata
    title = nc.getncattr('title')
    new_title = 'Annual Average of Daily ' + title
    new_frequency = 'yr'
    nc.setncatts({'title': new_title, 'frequency': new_frequency})
    # modify variable metadata
    long_name = nc.variables[variable].getncattr('long_name')
    new_long_name = 'Annual Average ' + long_name
    nc.variables[variable].setncattr('long_name', new_long_name)
    update_annual_avg_time_metadata(nc)
    nc.close()


def main(args):
    vars = '|'.join(args.variables)
    test_files = iter_matching(args.basedir, re.compile('.*({}).*(_rcp26|_rcp45|_rcp85|_historical_).*r1i1p1.*nc'.format(vars)))

    if args.dry_run:
        for f in test_files:
            print(f)
        sys.exit(0)

    for fp in test_files:
        log.info('Processing input file: {}'.format(fp))
        file_ = Cmip5File(fp, freq='yr', mip_table='yr')
        file_.root = args.outdir
        variable = file_.variable
        # calculate annual averages for all years in the file and store in a new NetCDF 
        out_fp = file_.fullpath
        log.info('Generating annual average output file: {}'.format(out_fp))
        create_annual_avg_file(fp, out_fp, variable)
        # update the metadata in the file generated by cdo.yearmean
        update_annual_avg_file_metadata(out_fp, variable)


if __name__ == '__main__':
    parser = ArgumentParser(description='Create annual averages from CMIP5 data')
    parser.add_argument('-o', '--outdir', required=True, help='Output folder')
    parser.add_argument('-b', '--basedir', help='Root directory from which to search for climate model output')
    parser.add_argument('-v', '--variables', nargs='+', help='Variables to include')
    parser.add_argument('-n', '--dry-run', dest='dry_run', action='store_true')
    parser.set_defaults(
        variables=['tasmin', 'tasmax'],
        basedir='/home/data/climate/CMIP5/CCCMA/CanESM2/',
        climdex=False,
        dry_run=False
    )
    args = parser.parse_args()
    main(args)
